package cli

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"sync"
	"sync/atomic"
)

type App struct {
  procs []*Process
  outDir string
  wg sync.WaitGroup
}

func (a *App) AddProc(p *Process) {
  p.num = len(a.procs) + 1
  a.procs = append(a.procs, p)
}

// Returns true if a process was deleted
func (a *App) RemoveProc(name string) bool {
  for i, proc := range a.procs {
    if proc.name == name {
      a.procs = append(a.procs[:i], a.procs[i+1:]...)
      return true
    }
  }
  return false
}

func (a *App) StartProcs() {
  for _, proc := range a.procs {
    if err := proc.Start(); err != nil {
      fmt.Printf(
        "error starting process %d (%s): %v\n", proc.num, proc.name, err,
      )
    }
  }
}

func (a *App) Wait() {
  a.wg.Wait()
}

func Run(args []string) {
  app := &App{}
  flag.StringVar(
    &app.outDir, "out-dir", ".", "Directory to put output files in",
  )
  flag.CommandLine.Parse(args)

  // Create the processes
  for i := 1; true; {
    name := readline(fmt.Sprintf("Process %d Name: ", i))
    if name == "" {
      break
    }
    prog := readline("Program: ")

    var args []string
    for i := 1; true; i++ {
      if arg := readline(fmt.Sprintf("Arg %d: ", i)); arg != "" {
        args = append(args, arg)
      } else {
        break
      }
    }

    env := os.Environ()
    for {
      if kv := readline(fmt.Sprintf("Env Var (key=val): ")); kv != "" {
        env = append(env, kv)
      } else {
        break
      }
    }

    outFilename := readline(
      "Stdout output filename (- = process number, % = name): ",
    )
    errFilename := readline(
      "Stderr output filename (- = process number, % = name): ",
    )

    conf := strings.ToLower(readline("Ok [Y/n]? "))
    if conf != "y" && conf != "yes" {
      continue
    }

    cmd := exec.Command(prog, args...)
    cmd.Env = env
    proc := &Process{
      app: app,
      name: name,
      num: i,
      cmd: cmd,
      outFilename: outFilename,
      errFilename: errFilename,
    }
    app.AddProc(proc)

    conf = strings.ToLower(readline("Start now [Y/n]? "))
    if conf == "y" || conf == "yes" {
      if err := proc.Start(); err != nil {
        fmt.Printf(
          "error starting process %d (%s): %v", proc.num, proc.name, err,
        )
      }
    }

    fmt.Println("====================")
    i++
  }
  fmt.Println("========================================")

  // Check for any deletions
  for {
    if name := readline("Delete any procs (enter name)? "); name != "" {
      break
    } else if !app.RemoveProc(name) {
      fmt.Println("No process with name: ", name)
    }
  }
  fmt.Println("========================================")

  // Start the processes
  fmt.Println("Starting (remaining) processes...")
  app.StartProcs()
  app.Wait()
}

type Process struct {
  app *App
  name string
  num int
  cmd *exec.Cmd
  outFilename, errFilename string
  outFile, errFile *os.File
  status atomic.Uint32
}

func (p *Process) Start() error {
  if p.status.Load() != statusNotStarted {
    return nil
  }
  var err error
  // Open the files for output
  if p.outFilename != "" {
    if p.outFilename == "-" {
      p.outFilename = fmt.Sprintf("process%d-stdout.txt", p.num)
    } else if p.outFilename == "%" {
      p.outFilename = fmt.Sprintf("%s-stdout.txt", p.name)
    }
    p.outFile, err = os.Create(filepath.Join(p.app.outDir, p.outFilename))
    if err != nil {
      fmt.Printf(
        "Error creating stdout output file for %s: %v\n",
        p.name, err,
      )
    }
    p.cmd.Stdout = p.outFile
  }
  if p.errFilename != "" {
    if p.errFilename == "-" {
      p.errFilename = fmt.Sprintf("process%d-stderr.txt", p.num)
    } else if p.errFilename == "%" {
      p.errFilename = fmt.Sprintf("%s-stderr.txt", p.name)
    }
    p.errFile, err = os.Create(filepath.Join(p.app.outDir, p.errFilename))
    if err != nil {
      fmt.Printf(
        "Error creating stderr output file for %s: %v\n",
        p.name, err,
      )
    }
    p.cmd.Stderr = p.errFile
  }
  // Start the process
  if err := p.cmd.Start(); err != nil {
    p.status.Store(statusFinished)
    fmt.Printf("Error starting %s: %v\n", p.name, err)
    // Delete the created files
    if p.outFile != nil {
      p.outFile.Close()
      if err := os.Remove(p.outFile.Name()); err != nil {
        fmt.Printf("Error removing stdout file for %s: %v\n", p.name, err)
      }
    }
    if p.errFile != nil {
      p.errFile.Close()
      if err := os.Remove(p.errFile.Name()); err != nil {
        fmt.Printf("Error removing stderr file for %s: %v\n", p.name, err)
      }
    }
    return err
  }
  p.status.Store(statusRunning)
  p.app.wg.Add(1)
  // Wait for the process to finish
  go func() {
    p.Wait()
  }()
  return nil
}

func (p *Process) Wait() {
  err := p.cmd.Wait()
  p.status.Store(statusFinished)
  if err != nil {
    fmt.Printf("%s terminated with error: %v\n", p.name, err)
  } else {
    fmt.Println(p.name, "finished")
  }
  // Close the files
  if p.outFile != nil {
    p.outFile.Close()
  }
  if p.errFile != nil {
    p.errFile.Close()
  }
  p.app.wg.Done()
}

const (
  statusNotStarted uint32 = iota
  statusRunning
  statusFinished
)

var stdinReader = bufio.NewReader(os.Stdin)

func readline(prompt ...string) string {
  if len(prompt) != 0 {
    fmt.Print(prompt[0])
  }
  line, err := stdinReader.ReadString('\n')
  if err != nil {
    panic(err)
  }
  return strings.TrimSpace(line)
}
/*
func Run(args []string) {
  app := &App{}
  var outDir string
  flag.StringVar(&outDir, "out-dir", ".", "Directory to put output files in")
  flag.StringVar(
    &app.outDir, "out-dir", ".", "Directory to put output files in",
  )
  flag.CommandLine.Parse(args)

  // Create the processes
  var procs []*Process
  for i := 1; true; i++ {
    name := readline(fmt.Sprintf("Process %d Name: ", i))
    if name == "" {
      break
    }
    prog := readline("Program: ")
    var args []string
    for i := 1; true; i++ {
      if arg := readline(fmt.Sprintf("Arg %d: ", i)); arg != "" {
        args = append(args, arg)
      } else {
        break
      }
    }
    env := os.Environ()
    for {
      if kv := readline(fmt.Sprintf("Env Var (key=val): ")); kv != "" {
        env = append(env, kv)
      } else {
        break
      }
    }
    choice := strings.ToLower(readline("Pipe stdout [Y/n]? "))
    pipeStdout := choice == "y" || choice == "yes"
    choice = strings.ToLower(readline("Pipe stderr [Y/n]? "))
    pipeStderr := choice == "y" || choice == "yes"

    cmd := exec.Command(prog, args...)
    cmd.Env = env
    procs = append(procs, &Process{
      name: name,
      cmd: cmd,
      pipeStdout: pipeStdout,
      pipeStderr: pipeStderr,
    })
    fmt.Println("====================")
  }
  fmt.Println("========================================")
  // Check for any deletions
  for {
    name := readline("Delete any procs (enter name)? ")
    if name == "" {
      break
    }
    deleted := false
    for i, proc := range procs {
      if proc.name == name {
        procs = append(procs[:i], procs[i+1:]...)
        deleted = true
        break
      }
    }
    if !deleted {
      fmt.Println("No process with name: ", name)
    }
  }
  fmt.Println("========================================")
  // Start the processes
  fmt.Println("Starting processes...")
  var wg sync.WaitGroup
  for i, proc := range procs {
    var err error
    // Open the files for output
    var stdoutFile, stderrFile *os.File
    if proc.pipeStdout {
      stdoutFile, err = os.Create(
        filepath.Join(outDir, fmt.Sprintf("process%d-stdout.txt", i+1)),
      )
      if err != nil {
        fmt.Printf(
          "Error creating stdout output file for %s: %v\n",
          proc.name, err,
        )
      }
      proc.cmd.Stdout = stdoutFile
    }
    if proc.pipeStderr {
      stderrFile, err = os.Create(
        filepath.Join(outDir, fmt.Sprintf("process%d-stderr.txt", i+1)),
      )
      if err != nil {
        fmt.Printf(
          "Error creating stderr output file for %s: %v\n",
          proc.name, err,
        )
      }
      proc.cmd.Stderr = stderrFile
    }
    // Start the process
    if err := proc.cmd.Start(); err != nil {
      fmt.Printf("Error starting %s: %v\n", proc.name, err)
      // Delete the created files
      if stdoutFile != nil {
        stdoutFile.Close()
        if err := os.Remove(stdoutFile.Name()); err != nil {
          fmt.Printf("Error removing stdout file for %s: %v\n", proc.name, err)
        }
      }
      if stderrFile != nil {
        stderrFile.Close()
        if err := os.Remove(stderrFile.Name()); err != nil {
          fmt.Printf("Error removing stderr file for %s: %v\n", proc.name, err)
        }
      }
      continue
    }
    // Wait for the process to finish
    wg.Add(1)
    go func(proc *Process, outFile, errFile *os.File) {
      if err := proc.cmd.Wait(); err != nil {
        fmt.Printf("%s terminated with error: %v\n", proc.name, err)
      } else {
        fmt.Println(proc.name, "finished")
      }
      if outFile != nil {
        outFile.Close()
      }
      if errFile != nil {
        errFile.Close()
      }
      wg.Done()
    }(proc, stdoutFile, stderrFile)
  }
  wg.Wait()
}
*/
