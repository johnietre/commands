#[derive(Clone, Copy, PartialEq, Eq, Default)]
struct Pos {
    x: usize,
    y: usize,
}

#[derive(Clone, Copy, PartialEq, Eq)]
enum Change {
    NA,
    Add,
    Del(usize),
}

#[derive(Clone, Copy, PartialEq, Eq)]
enum ProcessStatus {
    NotStarted,
    Running,
    Finished(ExitStatus),
}

struct Process {
    name: String,
    cmd: Command,
    child: Option<std::process::Child>,
    status: ProcessStatus,
}

#[allow(dead_code)]
impl Process {
    fn new(name: String, cmd: Command) -> Self {
        Self {
            name,
            cmd,
            child: None,
            status: ProcessStatus::NotStarted,
        }
    }

    fn start(&mut self) -> io::Result<()> {
        if self.is_alive() {
            return Err(Error::new(
                ErrorKind::InvalidInput,
                "process is already alive",
            ));
        }
        let child = self.cmd.spawn()?;
        self.child.replace(child);
        self.status = ProcessStatus::Running;
        Ok(())
    }

    fn kill(&mut self) -> io::Result<()> {
        if self.is_alive() {
            self.child.as_mut().expect("child is none").kill()
        } else {
            Err(Error::new(ErrorKind::InvalidInput, "process isn't alive"))
        }
    }

    fn interrupt(&mut self) -> io::Result<()> {
        if self.is_alive() {
            unsafe {
                libc::kill(
                    self.child.as_ref().expect("child is none").id() as _,
                    libc::SIGINT,
                )
            };
            Ok(())
        } else {
            Err(Error::new(ErrorKind::InvalidInput, "process isn't alive"))
        }
    }

    fn signal(&mut self, sig: libc::c_int) {
        // TODO: Return some kind of error?
        unsafe { libc::kill(self.child.as_ref().expect("child is none").id() as _, sig) };
    }

    fn is_alive(&self) -> bool {
        use ProcessStatus::*;
        match self.status {
            Running => true,
            NotStarted | Finished(_) => false,
        }
    }

    fn name(&self) -> &str {
        &self.name
    }

    fn id(&self) -> Option<u32> {
        Some(self.child.as_ref()?.id())
    }

    fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {
        if let ProcessStatus::Finished(status) = self.status {
            return Ok(Some(status));
        }
        Ok(
            match self.child.as_mut().expect("child is none").try_wait()? {
                Some(status) => {
                    self.child.take();
                    self.status = ProcessStatus::Finished(status);
                    Some(status)
                }
                None => None,
            },
        )
    }

    fn wait(&mut self) -> io::Result<ExitStatus> {
        if let ProcessStatus::Finished(status) = self.status {
            return Ok(status);
        }
        let status = self.child.take().expect("child is none").wait()?;
        self.status = ProcessStatus::Finished(status);
        Ok(status)
    }
}

unsafe fn run_multiple(_args: &Args) -> i32 {
    //let mut deferrer = Rc::new(RefCell::new(Deferrer::new()));
    let deferrer = Arc::new(Mutex::new(Deferrer::new()));
    let mut stdout = io::stdout().lock();
    let stdin_fd = io::stdin().as_raw_fd();
    // Get the old terminal and create the new
    let mut old_term = termios {
        c_iflag: 0,
        c_oflag: 0,
        c_cflag: 0,
        c_lflag: 0,
        c_line: 0,
        c_cc: [0; 32],
        c_ispeed: 0,
        c_ospeed: 0,
    };
    if libc::tcgetattr(stdin_fd, (&mut old_term) as *mut _) != 0 {
        die!(3, "error getting terminal info");
    }
    // Set panic handler
    let df = Arc::downgrade(&deferrer);
    std::panic::set_hook(Box::new(move |info| {
        eprintln!(
            "panic occurred: {}",
            info.payload().downcast_ref::<&str>().unwrap_or(&"")
        );
        if let Some(df) = df.upgrade() {
            df.lock().unwrap().force_run();
        }
    }));
    // Set ctrlc handler
    let running = Arc::new(AtomicBool::new(true));
    let (r, df) = (Arc::clone(&running), Arc::downgrade(&deferrer));
    ctrlc::set_handler(move || {
        // Second ctrl-c force quits
        if !r.swap(false, Ordering::SeqCst) {
            if let Some(df) = df.upgrade() {
                df.lock().unwrap().force_run();
            }
            exit(0);
        }
    })
    .unwrap_or_else(|_| die!(3, "error setting Ctrl-C handler"));
    // Set the terminal
    let new_term = termios {
        c_lflag: old_term.c_lflag & (!libc::ICANON & !libc::ECHO),
        c_cc: {
            let mut vals = old_term.c_cc;
            vals[libc::VMIN] = 0; // Minimum number of btyes required to be read
            vals[libc::VTIME] = 1; // Amount of time to wait before read returns
            vals
        },
        ..old_term
    };
    if tcsetattr(stdin_fd, TCSANOW, (&new_term) as *const _) != 0 {
        die!(3, "error setting terminal info");
    }
    deferrer.lock().unwrap().push_back(Box::new(move || {
        if tcsetattr(stdin_fd, TCSANOW, (&old_term) as *const _) != 0 {
            die!(3, "error resetting terminal info");
        }
    }));
    // TODO: Fix Deferrer; not going to run due

    print!("{}{}{}", SCREEN_SAVE, CLEAR_SCREEN, CUR_TO_HOME);
    stdout.flush().unwrap();
    let restore_func = deferrer.lock().unwrap().push_front(Box::new(move || {
        // TODO: Figure out better way to handle
        print!("{}{}{}", CLEAR_SCREEN, CUR_TO_HOME, SCREEN_RESTORE);
    }));

    let mut counter = 0;
    let mut children = LinkedList::new();
    let mut changed = Change::NA;
    let mut buf = [0 as u8; 3];
    // 1-based position
    let mut pos = Pos { x: 1, y: 1 };
    while running.load(Ordering::SeqCst) {
        if changed != Change::NA {
            let (skip, y, end) = match changed {
                Change::Add => (
                    children.len(),
                    children.len(),
                    format!("\r{}{}", children.back().unwrap(), CUR_TO_POS(1, pos.y)),
                ),
                Change::Del(y) => (y - 1, y, format!("{}{}", CLEAR_LINE, CUR_TO_POS(1, pos.y))),
                Change::NA => unreachable!(),
            };
            let changes = children
                .iter()
                .skip(skip)
                .fold(CUR_TO_POS(1, y), |acc, &v| {
                    acc + &format!("\r{}{}{}", CLEAR_LINE, v, CUR_DOWN)
                })
                + &end;
            print!("{}", changes);
            stdout.flush().unwrap();
            changed = Change::NA;
        }
        let n = read(stdin_fd, buf.as_mut_ptr().cast(), 3);
        if n == -1 {
            eprintln!("error reading from stdin, quitting");
            running.store(false, Ordering::SeqCst);
            break;
        } else if n == 0 {
            continue;
        }
        if n == 1 {
            match buf[0] {
                b'q' => {
                    running.store(false, Ordering::SeqCst);
                    break;
                }
                b'a' => {
                    counter += 1;
                    children.push_back(counter);
                    changed = Change::Add;
                }
                b'd' => {
                    if children.len() != 0 {
                        children = children
                            .into_iter()
                            .enumerate()
                            .filter(|(i, _)| *i != pos.y - 1)
                            .map(|(_, v)| v)
                            .collect();
                        changed = Change::Del(pos.y);
                        if pos.y != 1 {
                            pos.y -= 1;
                            print!("{}", CUR_TO_POS(1, pos.y));
                            stdout.flush().unwrap();
                        }
                    }
                }
                _ => panic!("{}", buf[0] as char),
            }
        } else if n == 2 {
            panic!("2");
        } else {
            // Arrow key
            if buf[0] == 27 && buf[1] == 91 {
                match buf[2] {
                    65 => {
                        if pos.y != 1 {
                            pos.y -= 1;
                            print!("{}", CUR_UP);
                            stdout.flush().unwrap();
                        }
                    }
                    66 => {
                        // Down
                        if children.len() != 0 && pos.y != children.len() {
                            pos.y += 1;
                            print!("{}", CUR_DOWN);
                            stdout.flush().unwrap();
                        }
                    }
                    67 => (), // Right
                    68 => (), // Right
                    _ => (),  // Unknown/unhandled sequence
                }
            } else {
                panic!("3");
            }
        }
    }

    restore_func.should_run(false);
    if children.len() == 0 {
        print!("{}{}", CUR_TO_HOME, SCREEN_RESTORE);
    } else {
        print!("{}\n{}", CUR_TO_POS(1, children.len()), SCREEN_RESTORE);
    };
    for _child in children.iter() {
        //libc::kill(child.id() as _, libc::SIGINT);
    }
    0
}
